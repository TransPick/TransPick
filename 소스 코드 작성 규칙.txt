### 명명 규칙에 관한 표준 ###

1. 일반 명명법
(1-1) 클래스 명과 메소드 명 파스칼 표기법으로 작성한다(첫 글자 대문자, EX : Main).
(1-2) 메소드 인자와 변수는 캐멀 표기법으로 작성한다(첫 글자 소문자, EX : totalCount).
(1-3) 인터페이스 명은 'I'+파스칼 표기법의 형태로 작성한다(EX : IEntity).
(1-4) 네임스페이스는 <회사 명>.<제품 명>.<상위 모듈>.<하위 모듈>과 같은 형식으로 작성한다.
(1-5) UI 구성요소는 알맞은 접두어를 붙여서 다른 변수와 구분한다.

2. 변수 명명법
(2-1) 변수 명에 헝가리안 표기법을 사용하지 않는다(변수명 앞에 자료형을 표기하는 방식, EX : string m_sName).
(2-2) i, j, k 등과 같이 한 글자로 이루어진 변수를 사용하지 않는다(EX : for (int i = 0; i < 10; i++) {...}).
(2-3) 지역 변수에 언더 스코어 문자를 사용하지 않는다(EX : string _count -> string count).
(2-4) 전역 변수는 언더 스코어로 시작해서 지역 변수랑 구분한다.
(2-5) 예약어와 유사한 변수 명은 사용하지 않는다.
(2-6) Boolean 값을 반환하는 메소드, 프로퍼티, 변수는 'is' 접두어를 붙인다.

3. 파일 명명법
(3-1) 해당 파일의 클래스 명을 파일 명으로 사용한다.
(3-2) 파일 명은 파스칼 표기법을 사용한다.



### 들여 쓰기 및 공백 처리에 관한 표준 ###

1. 들여 쓰기 처리 방법
(1-1) 들여 쓰기의 크기는 Space 기준 4번으로 한다.
(1-2) 주석은 코드와 같은 수준의 들여 쓰기에서 작성한다.
(1-3) 중괄호의 위치는 GNU와 K&R 스타일을 쓰지 않으며, BSD 스타일을 사용하도록 한다.

2. 공백 처리 방법
(2-1) 논리적으로 로직이 구분되는 곳에는 빈 줄을 삽입한다.
(2-2) 클래스 내의 메소드 사이의 구분은 빈 줄 하나로만 구분한다.
(2-3) 공백을 사용하는 명령이나 괄호 등의 구분에는 한 칸의 공백만을 사용한다.

3. 기타
(3-1) #region을 활용하여 관련 있는 코드를 묶도록 한다.
(3-2) private 한정자의 멤버 변수, 메소드는 파일의 맨 위에 두고, 그 바로 아래에 public 한정자의 멤버들을 작성한다.



### 변수 및 메소드 등의 작업 처리에 관한 표준 ###

1. 변수 관련
(1-1) System 네임스페이스에 정의된 자료형 대신 C#에서 제공하는 Alias 자료형을 이용한다.(EX : Int32 -> int, String -> string)
(1-2) 숫자 값을 하드코딩하지 않는다(대신 readonly나 const 사용).
(1-3) 문자열을 하드코딩하지 않는다(대신 리소스 파일을 사용).
(1-4) 문자열을 초기화 할 때에 "" 대신 string.Empty를 사용하도록 한다.
(1-5) 전역 변수의 사용을 자제하도록 한다. 여러 메소드에서 사용해야 할 필요가 있는 변수는 메소드의 인자로 전달하는 구조를 사용한다.
(1-6) 열거형(enum) 대신 숫자나 문자열을 사용하지 않는다.
(1-7) 전역 변수를 public이나 protected 한정자로 선언하지 않도록 하며, private으로 선언한 후에 public 혹은 protected 프로퍼티로 노출하도록 한다.
(1-8) 로컬 경로나 드라이브 명을 하드코딩하지 않는다. 
(1-9) 변수 선언은 해당 변수가 최초로 사용되는 곳에 선언하며, 한 줄에 하나의 변수만 선언하도록 한다.

2. 메소드 관련
(2-1) 메소드는 25줄 내외 정도로 짧게 작성하며, 길다면 리팩토링을 통해 분리하도록 한다.
(2-2) 메소드 명은 수행하는 역할이 잘 드러나게 작성하도록 한다.
(2-3) 아무라 작은 단위의 작업일지라도 하나의 메소드는 오직 하나의 작업만 하도록 설계한다.
(2-4) 메소드에 너무 많은 인자를 넘기지 않도록 한다. 만약 4~5개 이상의 인자가 전달되는 메소드가 있다면 클래스 혹은 메소드의 구조를 재조정하도록 한다.
(2-5) 컬렉션을 반환 값으로 가지는 메소드의 경우, 만약 값이 없는 경우에는 null을 리턴하지 않고 빈 컬렉션을 넘겨주도록 한다. NullReferenceException의 발생 가능성이 줄어든다.

3. 작업 처리 관련
(3-1) 하나의 파일에는 하나의 클래스만 작성하도록 한다.
(3-2) 영문 문자열을 비교할 때에는 대소문자 중 하나로 변경한 후 수행한다(일부 경우 제외).
(3-3) 실행 경로가 특정한 곳일 거라는 가정 하에 코딩하지 않는다.
(3-4) 너무 긴 소스 코드를 가지는 클래스를 작성하지 않도록 한다. 만약 1000 라인 이상이 된다면, 리팩토리 대상으로 삼아도 좋으므로 두 클래스 이상으로 분리하도록 한다.
(3-5) public 메소드나 프로퍼티는 꼭 필요한 곳에서만 사용하도록 하고, 만약 동일 어셈블리 내에서만 사용될 경우 internal 한정자를 사용하도록 한다.
(3-6) 파일 스트림 등 IDisposable을 구현하는 메소드는 닫는 로직을 finally에 둬서 오류가 발생하더라도 마지막에 닫히도록 해준다.
(3-7) 문자열이 길거나 반복문에서 문자열 처리를 해야 할 때는 자원 낭비를 최소화하기 위해 String 클래스 대신 StringBuilder 클래스를 사용하도록 한다. 

4. 이벤트 관련 
(4-1) 이벤트 핸들러에서 해당 이벤트의 작업을 수행하지 말고 별도의 메소드를 호출하여 처리하도록 한다.
(4-2) 클릭과 같이 이벤트 핸들러에서 호출하는 별도의 작업 메소드를 직접 호출하지 않도록 한다. 만약 필요한 경우에는 해당 이벤트 핸들러를 호출하도록 한다.

5. 예외 처리 관련
(5-1) 언제나 예상치 못한 값에 대비하도록 한다.
(5-2) 예외를 처리할 때, 예외는 Exception 하나로 통일하지 않도록 하고, 가능한 한 모든 경우를 고려할 수 있도록 한다.

6. 주석 관련
(6-1) 코드 라인의 끝이 아닌 별도의 줄에 주석을 배치한다.
(6-2) 주석 텍스트는 대문자로 시작하도록 하며 끝에는 마침표를 붙인다.
(6-3) 주석 구분 기호 '//'과 주석 텍스트 사이에는 공백을 하나 삽입하도록 한다.

7. 기타
(7-1) 애플리케이션이 시작되면 초기화 과정을 수행하여 필요한 파일들이 있는지 등을 확인하고 문제가 있다면 사용자에게 알리도록 한다.
(7-2) 환경 설정 파일이 없다면 기본 설정의 파일을 만들어주도록 한다.
(7-3) 환경 설정 파일 등에서 문제가 있는 값이 있다면 문제가 있는 항목과 함께 어떠한 값이 올바른 값인지를 보여주도록 한다.
(7-4) 사용자에게 오류 내용과 관련한 메시지를 띄울 때에는 단순한 오류 코드 대신에 세부 정보를 알려주도록 한다.
(7-5) 오류 메시지를 띄울 때에는 해결 방법도 함께 제시하도록 한다.
(7-6) 사용자에게는 짧고 명료한 메시지를 보여주되, 실제로는 파악 가능한 모든 정보를 기록한 로그 파일을 만들어 두도록 한다.
(7-7) 어셈블리 명, 설명, 버전, 저작권 정보 등을 AssemblyInfo 파일에 작성해두도록 한다.
(7-8) 프로젝트에 사용하는 파일들은 폴더를 이용하여 논리적으로 분리하도록 한다. 상위 폴더와 하위 폴더의 2단계 계층 구조를 기본으로 하며, 만약 폴더가 많아서 분리가 어려운 경우 어셈블리를 별도로 분리하도록 한다.
(7-9) 정보 표시 혹은 오류 기록 등을 목적으로 하는 제대로 된 로그 클래스를 작성하도록 한다.